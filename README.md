# Experiment6

در این آزمایش ما در دو مرحله کلاس Package را تکمیل کردیم

## State Pattern

در مرحله‌ی اول یک فیلد state برای آن در نظر گرفتیم و دو وضعیت مختلف یعنی در ترانزیت و به مقصد رسیده را با استفاده از الگوی State پیاده‌سازی کردیم.

از آنجایی که این وضعیت‌ها نسبت‌ به هم دید دارند و حتی در پیاده‌سازی ما وضعیت InTransit خودش به Delivered تبدیل می‌شود وجود این ارتباط و با خبر بودن وضعیت‌ها از یکدیگر را نشان می‌دهد.

از آنجایی که یکی از تفاوت‌های اصلی دو الگوی استیت و استراتژی همین با خبر بودن استیت‌‌ها نسبت به همدیگر بود در این قسمت از این الگو استفاده کردیم.

در این الگو با توجه به استیت فعلی و ورودی کاربر وضعیت آپدیت می‌شود و اینکار بدون switch case در تابع اصلی انجام می‌شود. پس این الگو تحقق پیدا کرده است

## Strategy Pattern

در مرحله‌ی دوم یک فیلد استراتژی در نظر گرفته شده است که خودش به صورت خودبه‌خودی مقدار هزینه را با توجه به وزن بسته محاسبه می‌کند.

از آنجایی که در الگوی استراتژی، استراتژی‌های مختلف نسبت به یکدیگر خبر ندارند به همین دلیل در تابع اصلی فقط با توجه به ورودی کاربر استراتژی بسته را تغییر می‌دهیم تا در زمان محاسبه خود استراتژی بدون نیاز به switch case مقدار درست را محاسبه کند.

پس با توجه به توضیحات داده شده این الگو نیز به درستی پیاده‌سازی شده است.

## Questions

### 1

با استناد به این کتاب الگو‌ها را به سه دسته تقسیم می‌کنیم.

الگوهای ساختاری: این الگوها برای طراحی ساختارهای متفاوت و ارتباطات بین اجزا استفاده می‌شوند، مانند Adapter و Proxy می‌توان نام برد

الگوهای رفتاری: این الگوها برای مدیریت الگوهای رفتاری اجزا و ارتباطات آن‌ها به کار می‌روند، مانند Strategy و State می‌توان گفت

الگوهای سازنده: این الگوها برای مدیریت فرایند ساخت و اجتماع اجزا استفاده می‌شوند، مانند Singleton و Builder هستند

### 2

الگوهای استفاده شده در آزمایش قسمت قبل یعنی Strategy و State به دسته الگوهای رفتاری تعلق دارند

### 3

برای ایجاد یک بسته که در هر اجرا محصراً یکی از آن‌ها وجود دارد، الگوی Singleton مناسب است. این الگو به دلیل اینکه فقط یک نمونه از یک کلاس مورد نیاز است و می‌خواهیم اطمینان حاصل کنیم که همیشه همان نمونه مورد استفاده قرار می‌گیرد، مناسب است

### 4

تحقق اصول SOLID در این الگو به این صورت است1. اصل تک مسئولیت (Single Responsibility Principle - SRP):

نقض SRP: الگوی Singleton مسئولیت های متعددی را بر عهده دارد، از جمله:
مدیریت چرخه حیات شیء (ایجاد، دسترسی و حذف)
ارائه نقطه دسترسی جهانی به شیء
تضمین وجود تنها یک نمونه از شیء
توجیه: این وظایف به طور ذاتی با یکدیگر مرتبط هستند و الگوی Singleton را به یک ابزار مفید برای مدیریت اشیاء تکرارشونده تبدیل می کنند.

2. اصل جدایی رابط ها (Interface Segregation Principle - ISP):

نقض ISP: الگوی Singleton رابط های زیادی را در معرض دید قرار می دهد، از جمله:
متد برای ایجاد نمونه
متد برای دسترسی به نمونه
متد برای بررسی وجود نمونه
توجیه: این رابط ها برای عملکرد صحیح الگوی Singleton ضروری هستند و جداسازی آنها می تواند منجر به پیچیدگی بیشتر شود.

3. اصل جایگزینی پذیری وابستگی ها (Liskov Substitution Principle - LSP):

نقض LSP: الگوی Singleton به طور کامل از اصل جایگزینی پذیری پشتیبانی نمی کند.
توجیه: از آنجا که فقط یک نمونه از کلاس Singleton وجود دارد، جایگزینی آن با کلاس مشتق شده دشوار است.

4. اصل جداسازی مشغله ها (Open-Closed Principle - OCP):

نقض OCP: الگوی Singleton به طور کامل از اصل جداسازی مشغله ها پشتیبانی نمی کند.
توجیه: برای تغییر رفتار کلاس Singleton، باید مستقیماً کد آن را اصلاح کنید، که بر خلاف اصل OCP است.

5. اصل وابستگی معکوس (Dependency Inversion Principle - DIP):

تطابق DIP: الگوی Singleton به طور کامل از اصل وابستگی معکوس پشتیبانی می کند.
توجیه: کلاس های دیگر به جای وابستگی به نمونه Singleton، به رابط آن وابسته هستند. این امر جداسازی و تست پذیری را افزایش می دهد.
