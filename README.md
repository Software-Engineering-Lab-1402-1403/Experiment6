# Experiment6

در این آزمایش ما در دو مرحله کلاس Package را تکمیل کردیم

## State Pattern

در مرحله‌ی اول یک فیلد state برای آن در نظر گرفتیم و دو وضعیت مختلف یعنی در ترانزیت و به مقصد رسیده را با استفاده از الگوی State پیاده‌سازی کردیم.

از آنجایی که این وضعیت‌ها نسبت‌ به هم دید دارند و حتی در پیاده‌سازی ما وضعیت InTransit خودش به Delivered تبدیل می‌شود وجود این ارتباط و با خبر بودن وضعیت‌ها از یکدیگر را نشان می‌دهد.

از آنجایی که یکی از تفاوت‌های اصلی دو الگوی استیت و استراتژی همین با خبر بودن استیت‌‌ها نسبت به همدیگر بود در این قسمت از این الگو استفاده کردیم.

در این الگو با توجه به استیت فعلی و ورودی کاربر وضعیت آپدیت می‌شود و اینکار بدون switch case در تابع اصلی انجام می‌شود. پس این الگو تحقق پیدا کرده است

## Strategy Pattern

در مرحله‌ی دوم یک فیلد استراتژی در نظر گرفته شده است که خودش به صورت خودبه‌خودی مقدار هزینه را با توجه به وزن بسته محاسبه می‌کند.

از آنجایی که در الگوی استراتژی، استراتژی‌های مختلف نسبت به یکدیگر خبر ندارند به همین دلیل در تابع اصلی فقط با توجه به ورودی کاربر استراتژی بسته را تغییر می‌دهیم تا در زمان محاسبه خود استراتژی بدون نیاز به switch case مقدار درست را محاسبه کند.

پس با توجه به توضیحات داده شده این الگو نیز به درستی پیاده‌سازی شده است.

## Questions

### 1

با استناد به این کتاب الگو‌ها را به سه دسته تقسیم می‌کنیم.

الگوهای ساختاری: این الگوها برای طراحی ساختارهای متفاوت و ارتباطات بین اجزا استفاده می‌شوند، مانند Adapter و Proxy می‌توان نام برد

الگوهای رفتاری: این الگوها برای مدیریت الگوهای رفتاری اجزا و ارتباطات آن‌ها به کار می‌روند، مانند Strategy و State می‌توان گفت

الگوهای سازنده: این الگوها برای مدیریت فرایند ساخت و اجتماع اجزا استفاده می‌شوند، مانند Singleton و Builder هستند

### 2

الگوهای استفاده شده در آزمایش قسمت قبل یعنی Strategy و State به دسته الگوهای رفتاری تعلق دارند

### 3

برای ایجاد یک بسته که در هر اجرا محصراً یکی از آن‌ها وجود دارد، الگوی Singleton مناسب است. این الگو به دلیل اینکه فقط یک نمونه از یک کلاس مورد نیاز است و می‌خواهیم اطمینان حاصل کنیم که همیشه همان نمونه مورد استفاده قرار می‌گیرد، مناسب است

### 4

تحقق اصول SOLID در این الگو به این صورت است

1. اصل تک مسئولیت (Single Responsibility Principle - SRP):

نقض SRP: الگوی Singleton مسئولیت های متعددی را بر عهده دارد، از جمله:
مدیریت چرخه حیات شیء (ایجاد، دسترسی و حذف)
ارائه نقطه دسترسی جهانی به شیء
تضمین وجود تنها یک نمونه از شیء
توجیه: این وظایف به طور ذاتی با یکدیگر مرتبط هستند و الگوی Singleton را به یک ابزار مفید برای مدیریت اشیاء تکرارشونده تبدیل می کنند.

یک کلاس باید تنها یک دلیل برای تغییر داشته باشد. الگوهای تک‌تایی اغلب مسئولیت‌های متعددی مانند مدیریت وضعیت (state)، ارائه یک رابط و کپسوله‌سازی منطق دارند. این امر می‌تواند درک و نگهداری آن‌ها را دشوار کند.

2. اصل جدایی رابط ها (Interface Segregation Principle - ISP):

نقض ISP: الگوی Singleton رابط های زیادی را در معرض دید قرار می دهد، از جمله:
متد برای ایجاد نمونه
متد برای دسترسی به نمونه
متد برای بررسی وجود نمونه
توجیه: این رابط ها برای عملکرد صحیح الگوی Singleton ضروری هستند و جداسازی آنها می تواند منجر به پیچیدگی بیشتر شود.

3. اصل جایگزینی پذیری وابستگی ها (Liskov Substitution Principle - LSP):

تصور اینکه الگوی طراحی Singleton مانع از ارث بری (inheritance) می شود. این تصور کاملا اشتباه است.

طبق کتاب الگوهای طراحی (GoF) در صفحه ۱۲۷:

از الگوی Singleton زمانی استفاده کنید که:

به طور دقیق باید تنها یک نمونه از یک کلاس وجود داشته باشد و از طریق یک نقطه دسترسی شناخته شده برای سایر بخش های برنامه در دسترس باشد.
تنها نمونه موجود باید قابلیت توسعه از طریق ارث بری داشته باشد و بخش های برنامه بتوانند از نمونه توسعه یافته بدون نیاز به تغییر کد خود استفاده کنند.
... و مجددا در صفحه ۱۲۸:

الگوی Singleton مزایای متعددی دارد:

امکان بهبود عملیات و نمایش. کلاس Singleton قابل ارث بری است و پیکربندی یک برنامه با نمونه ای از این کلاس توسعه یافته آسان است. شما می توانید برنامه را با نمونه ای از کلاسی که در زمان اجرا نیاز دارید، پیکربندی کنید.
صفحه ۱۳۰ به جزئیات پیکربندی زیرمجموعه های Singleton می پردازد.

پاسخ به اینکه چرا Singleton اصل OCP را نقض می کند این است که این الگو ذاتا این اصل را نقض نمی کند. صرفا به دلیل اینکه اکثر توسعه دهندگان بدون مطالعه کتاب GoF، این الگو را به گونه ای که اصل OCP را نقض می کند، پیاده سازی می کنند، این تصور به وجود آمده است. الگوی Factory Method نیز به سرنوشت مشابهی دچار شده است.

4. اصل جداسازی مشغله ها (Open-Closed Principle - OCP):

نقض OCP:
موجودیت‌های نرم‌افزاری (کلاس‌ها، ماژول‌ها، توابع) باید برای توسعه باز باشند، اما برای تغییر بسته باشند.  تک‌تایی‌ها به دلیل ماهیت جهانی (global) و وابستگی شدید به سایر قسمت‌های کد، به سختی قابل توسعه هستند. هر تغییری در تک‌تایی می‌تواند به طور بالقوه سایر قسمت‌های کد را خراب کند.

5. اصل وابستگی معکوس (Dependency Inversion Principle - DIP):

تطابق DIP: الگوی Singleton به طور کامل از اصل وابستگی معکوس پشتیبانی می کند.
توجیه: کلاس های دیگر به جای وابستگی به نمونه Singleton، به رابط آن وابسته هستند. این امر جداسازی و تست پذیری را افزایش می دهد.

ماژول‌های سطح بالا نباید به ماژول‌های سطح پایین وابسته باشند. هر دو باید به انتزاعات (abstractions) وابسته باشند. تک‌تایی‌ها می‌توانند وابستگی‌های شدیدی بین کلاس‌ها ایجاد کنند و تست و استفاده مجدد از کد را دشوار سازند.
